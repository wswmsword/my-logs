# 开发键盘可访问的界面

原文：*https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/*

原文日期：无日期

原文作者：[ARIA Authoring Practices Guide (APG)](https://www.w3.org/WAI/ARIA/apg/)

翻译日期：翻译中

## 介绍

对于那些使用 ARIA 保持可访问性的图形用户界面（GUI）组件，开发者必须在代码中提供键盘支持，因为它们不像原生 HTML 表单元素，浏览器不会提供额外的键盘支持。本文会介绍开发包含 ARIA 组件的 web 页面的原则和方法，例如菜单和表格，以及可以通过键盘操作的交互式组件，例如工具栏和对话框。除了焦点管理的基础知识以外，对于以向依赖键盘的人获得和其它人一样有效和愉悦体验为目标，也提供了指导。

本篇文章内容包括：
1. 理解在 ARIA 设计模版里使用的焦点移动约定的基本原则；
2. 维护可见的焦点、可预测的焦点移动，以及区分键盘焦点和选中状态；
3. 管理组件之间的键盘焦点移动，例如，在按下 <kbd>Tab</kbd> 和 <kbd>Shift+Tab</kbd> 的时候焦点如何移动；
4. 在含有多个可聚焦元素的组件内管理键盘焦点的移动，例如，在单选组、菜单、列表框、树和表格之类的组件以编程方式暴露焦点的两种方法；
5. 确定被禁用的可交互元素可以被聚焦的时机；
6. 指定并暴露键盘快捷键，包括关于如何避免和辅助技术、浏览器以及操作系统的快捷键相冲突的一份指导。

## 基本的键盘导航约定

ARIA 角色、状态和属性的可访问性行为和特性，这些在流行的桌面端 GUI 的 GUI 组件之间是共享的，比如微软 Windows、macOS 和 GNOME。同样，ARIA 设计模版借鉴了这些平台的用户期望和键盘约定，为了达到促进贯穿 web 的键盘界面的易于学习和高效操作的目的，持续地集成通用约定。

为了让页面可访问，所有的可交互元素必须能通过键盘操作。另外，在 [APG 模版](https://www.w3.org/WAI/ARIA/apg/patterns/)里描述的通用 GUI 键盘界面约定的一致性运用也是重要的，尤其对于辅助技术用户来说。举个例子，考虑屏幕阅读器用户正在操作一个树形结构，就像熟悉的视觉样式会告诉用户如何通过鼠标展开子树一样，ARIA 属性为用户提供了一个树形结构的声音提示和感受。因此，屏幕阅读器用户通常会期望按下右箭头来展开一个收起的节点。由于屏幕阅读器已经知道元素是树形结构，所以它也会指导新手如何操作这棵树。类似的，语音识别软件也可以实现展开或收起子树的命令，这是因为它能够识别元素是树形结构，并且能够处理类似的键盘命令。所有的这些，会在实现了类似[树形视图模版](https://www.w3.org/WAI/ARIA/apg/patterns/treeview/)所描述的 GUI 键盘约定之后成为现实。

一个在每个平台的通用键盘导航约定是用 <kbd>Tab</kbd> 和 <kbd>Shift+Tab</kbd> 在 UI 组件之间移动，其它还有方向键，会在内部有多个可聚焦元素的组件控制焦点的移动。当按下 <kbd>Tab</kbd> 时，焦点的路径被称为 tab 序列或者 tab 环。

常见的包含多个可聚焦元素的 UI 组件的例子有，单选组、tab 列表、菜单和表格。例如一个单选组，包含多个单选按钮，每一个都是可聚焦的，然而，只有一个单选按钮是在 tab 序列中的。按下 <kbd>Tab</kbd> 之后，焦点移动至单选组的其中一个单选按钮，按下方向键，焦点在焦点组内的每一个焦点按钮上移动，继续按下 <kbd>Tab</kbd>，焦点移出单选组并聚焦 tab 序列的下一个元素。

ARIA 规范把包含多个可聚焦元素的 UI 组件成为一个[复合](https://w3c.github.io/aria/#composite)微件（widget）。在复合微件内部控制焦点移动的过程称为焦点管理。下面是一些包含演示焦点管理的实现范例的 ARIA 设计模版：
- [Combobox](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/)
- [Grid](https://www.w3.org/WAI/ARIA/apg/patterns/grid/)
- [Listbox](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/)
- [Menu and Menubar](https://www.w3.org/WAI/ARIA/apg/patterns/menubar/)
- [Radio Group](https://www.w3.org/WAI/ARIA/apg/patterns/radio/)
- [Tabs](https://www.w3.org/WAI/ARIA/apg/patterns/tabs/)
- [Toolbar](https://www.w3.org/WAI/ARIA/apg/patterns/toolbar/)
- [Treegrid](https://www.w3.org/WAI/ARIA/apg/patterns/treegrid/)
- [Tree View](https://www.w3.org/WAI/ARIA/apg/patterns/treeview/)

## 可辨识和可预测的键盘焦点

跟踪[议题 217](https://github.com/w3c/aria-practices/issues/217) 完成本章节。

在使用键盘的时候，有两个良好体验的基本要素，分别是能够轻松辨识焦点的位置和能够找到按下导航键的下一个聚焦元素。 The following factors affect to what extent a web page affords users these capabilities.
1. 焦点的视觉指示：用户需要能够轻松辨识键盘焦点和其它视觉设计特性。就像鼠标用户会移动鼠标找到指针，键盘用户会按下导航按键来观察移动。如果响应焦点移动的视觉变化是细微的，用户就会失去焦点的跟踪而无法继续操作。我们建议开发者依靠浏览器默认的焦点指示，如果要自定义，需要考虑：
	- 高对比度下，颜色和渐变可能消失；
	- 用户要能轻松区分聚焦和选中，如[聚焦 VS 选中，以及双重聚焦的感知](#聚焦-vs-选中，以及双重聚焦的感知)所述，尤其是在组件包含选中的元素而没有焦点的情况；
	- ……等待添加的其他情况……
2. 焦点的持续性：用户界面的总是要有一个组件是活动（document.activeElement 不为空或不为 body 元素）的，并且活动元素有一个视觉的焦点指示。开发者需要管理影响当前活动元素的事件，来保持焦点视觉可见以及移动符合逻辑。举个例子，如果用户关闭对话框或者执行了类似删除列表某项之类的破坏性操作，活动元素可能会被隐藏或者被从 DOM 中移除。如果这样的事件没有管理，没有设置焦点回到那个触发打开对话框或删除列表单项的按钮上，浏览器会将焦点移至 body 元素，会导致用户界面的焦点丢失。
3. 移动可预测：键盘界面的可用性很大程度上由用户能否轻易的猜测焦点在按下导航按键后会聚焦哪里决定。一些增强可预测性的方法包括：
	- 以符合页面语言阅读顺序的模式来移动焦点，例如在从左到右顺序的语言中，创建一个焦点是从左到右、从上到下的序列；
	- 在进入页面的下一部分前，把页面当前部分的元素放入焦点序列。例如有一个多列布局的页面，包含左侧栏、中心区域和右侧栏，在进入中心区域的第一个元素前，建立一个包含左侧栏所有元素的 tab 序列；
	- 当 tab 序列两个连续元素的距离过于遥远的时候，避免移动被当作卡顿、迟缓的问题。举个例子，一个左右顺序语言的页面，要从主要区域右下角的最后一个元素跳到左侧栏的最上面的元素，会有些不可预测，也很难跟上焦点的移动，尤其对于视线狭窄的用户来说更是如此；
	- 让网站保持一致的模式。当相似的页面有相似的焦点移动模式的时候，键盘的体验会更加容易预测；
	- 不要在加载页面后设置初始焦点，除非以下情况：
		- 页面提供了单一的主要的一个功能，几乎所有用户会在页面加载后立即使用该功能；
		- 提供给用户的内容都是页面上的常用功能。

## 聚焦 VS 选中，以及双重聚焦的感知

有时，页面会出现同时有两个元素聚焦的情况。举个例子，有一个多选列表框，选中的项会变成灰色，然而，焦点仍然可以在其它选项之间移动。类似的，如果用户激活了选项卡的某一选项，这个选项的状态会被设置为已选中，并且改变外观样式，然而，用户仍然能够继续导航，在页面的其它地方移动，并且选项卡的选项仍然保持选中状态和样式。

聚焦和选中很不一样。从键盘用户的角度看，焦点就是指针，就像鼠标，它能跟踪导航的路径。任何时候只有一个焦点，且任何操作都在焦点上执行。另一方面，选中是一种可以在微件中执行的操作，例如列表框、树形结构以及选项卡。如果微件只能支持一个焦点，那么会只允许一项被选中，并且选中的状态会跟随焦点在微件里的移动而移动。也即在有的微件里移动焦点就是执行选中。然而，如果微件支持多选的话，不止一个选项会被设置为选中状态，并且移动焦点的按键不会触发选中。一些多选微件同时支持移动焦点和选中的键盘命令，但这些案件和常规导航按键不一样。最后，焦点离开有选中状态的微件时，选中状态会一直保持。

已开发者的角度来看，这些区别都很容易——聚焦元素是活动的元素（document.activeElement），而选中的元素则是具有 `aria-selected=true` 的元素。

关于聚焦和选中的状态，设计人员和开发人员需要考虑：
- 聚焦的指示点必须总是可见的；
- 选中的状态必须和焦点不相同。

## 何时让选中同步聚焦

在只能选中一个元素的组合微件中，移动焦点可能会导致聚焦元素成为选中的元素，例如选项卡或者单选列表框。这就是所谓的选中聚焦。选中聚焦通常对用户友好，但在有些情况，也会有害可访问性。

举个例子，一个选项卡，选中的状态表示哪一个面板正在被展示。如果在选项卡使用选中聚焦，焦点在不同选项间移动会自动改变选项面板的展示。如果内容是保存在 DOM 中，那么一个新的面板会在瞬间被展示。如果键盘用户希望展示一共六个选项卡的第三个，只需要快速按下右箭头 3 次即可。并且，通过选项的标注来导航的屏幕阅读器用户可以高效、无延迟地阅读完整的内容。

但是，如果展示新的选项面板会导致网络请求或页面刷新，那么对于键盘和屏幕阅读器用户，选中聚焦的体验是极差的。这样的场景，展示第四个选项面板时，在每一移动焦点的严重延迟下，会变得单调且耗时。如果展示一个新面板会导致页面刷新，那用户不仅要等待加载，还要重新导航到选项卡。

如果不使用选中聚焦，用户要可以通过按下 <kbd>Enter</kbd> 或 <kbd>Space</kbd> 来执行选中。

## 组件之间的键盘导航（Tab 序列）

正如在[基本的键盘导航约定](#基本的键盘导航约定)一节中解释的，所有的交互式 UI 组件都需要能通过键盘访问。This is best achieved by either including them in the tab sequence or by making them accessible from a component that is in the tab sequence, e.g., as part of a composite component.本章节讨论了如何建立和管理 tab 序列，随后的章节介绍如何使组件内的可聚焦元素变得键盘可访问。

[HTML tabindex](https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute) 和 [SVG2 tabindex](https://www.w3.org/TR/SVG2/struct.html#tabindexattribute) 属性可以被用来把某个元素加入或者删除 tab 序列。tabindex 的值也会影响 tab 序列的顺序，但还是强烈建议不要使用 tabindex 来改变顺序。

HTML 里，默认情况下，tab 序列包括链接和 HTML 表单元素，在 macOS 下只有表单元素。macOS 的偏好设置里有键盘的设定选项，打开后能够让 tab 按键访问所有的可聚焦元素（包括链接）。

默认的 tab 序列的顺序是元素在 DOM 里的顺序。DOM 的顺序也决定了屏幕阅读器的阅读顺序。保持键盘的 tab 序列和屏幕阅读器阅读顺序一致、有逻辑、可预测（[可辨识和可预测的键盘焦点](#可辨识和可预测的键盘焦点)）很重要。在操作 tab 序列的同时维持阅读顺序的一致，最鲁棒的方法就是在浏览器中对 DOM 元素进行重新排序。

Tabindex 的值会产生以下影响。

**‌无 tabindex 属性或者不是有效的值**

元素会保持默认的聚焦行为。在 HTML 中，只有表单控件和带 HREF 属性的链接会被包含 tab 序列。

**tabindex="0"**

元素基于在 DOM 中的位置被包含在 tab 序列中。

**tabindex="-1"**

元素不在 tab 序列内，但是可以通过 element.focus() 聚焦。

**‌tabindex="X"，X 是一个大于 0 小于 32768 的整数**

强烈不建议使用这些值。元素会基于 tabindex 的值决定在 tab 序列中的位置。tabindex 值为 0 的元素的默认访问顺序会排在 tabindex 值为 1 或大于 1 的元素之后。

## 组件内部的键盘访问

正如在[基本的键盘导航约定](#基本的键盘导航约定)中介绍的，在 tab 序列里，一个组合 UI 组件只能包含一个可聚焦元素。只要组件内有了焦点，就需要用除 <kbd>Tab</kbd> 和 <kbd>Shift + Tab</kbd> 以外的按键来让用户在可聚焦元素之间移动。开发者可以自由设定组件内移动焦点的按键，但是强烈建议如 [APG 模版](https://www.w3.org/WAI/ARIA/apg/patterns/)里介绍的，使用和通用 GUI 操作系统的组件类似的键盘按键设定。

当通过 <kbd>Tab</kbd> 让一个组件获得了焦点，这个焦点的位置由组件的类型决定。通常这是下面几种情况。
- 元素的焦点是组件最后一次聚焦焦点的位置。或者，改组件还没有被聚焦过，那么元素的焦点是第一个元素。表格和树形表格通常会使用这个模式。
- 选中的元素。或者，如果没有元素被选中过，那么第一个元素被聚焦。通常单选组、选项卡、列表框、树形结构之类的微件会使用这个模式。注意：对于选项组，聚焦的元素的状态是 checked，而不是 selected，状态 selected 不支持单选按钮。
- 第一个元素。这种模式被用在菜单或工具栏上。

下面的小节解释了组件中管理焦点的两个策略：创建流动 index 和使用属性 aria-activedescendant。

### 使用流动 tabindex 管理组件内的焦点

当用流动 tabindex 管理 UI 组件焦点的时候，在 tab 序列的元素 tabindex 为 “0”，而其它的可聚焦元素的 tabindex 为 “-1”。下面的算法描述了流动 tabindex 策略。
- 当组件被创建，把将要被初始化包含在 tab 序列的元素设置为 `tabindex=0`，其它的可聚焦元素设置为 `tabindex=-1`；
- 如果组件包含焦点，用户在组件里按下导航按键移动焦点，例如方向键：
	- 将 `tabindex=0` 的元素设为 `tabindex=-1`；
	- 将通过键盘事件即将聚焦的元素设为 `tabindex=0`;
	- 进行聚焦，对有 `tabindex=0` 的元素执行 `element.focus()`。
- 如果设计上要求通过 <kbd>Tab</kbd> 和 <kbd>Shift+Tab</kbd> 来聚焦组件的特定元素，那么当组件失去焦点的时候，也要检查目标元素是否有 `tabindex=0`。如果没有，需要为目标元素设置 `tabindex=0`，并且为之前是 `tabindex=0` 的元素设置为 `tabindex=-1`。

使用流动 tabindex 管理焦点相对于 aria-activedescendant 的一个好处是，可以让用户代理的视图滚动到最近聚焦的地方。

### 使用 aria-activedescendant 管理组件内的焦点

如果组件有支持属性 aria-activedescendant 的 ARIA 角色，那么操作 tabindex 来移动焦点就不是必须的了。取而代之，只有容器元素需要在 tab 序列中。当容器有了 DOM 焦点，容器上的 aria-activedescendant 的值就会告诉辅助技术，微件中的哪个元素是活跃元素。辅助技术会将活跃元素作为聚焦元素，即使 DOM 焦点在有属性 aria-activedescendant 的元素上。而且，当 aria-activedescendant 的值发生改变，辅助技术会收到焦点变化的事件，这和 DOM 焦点发生变化是等价的。

下面是使用 aria-activedescendant 来管理焦点的步骤。
- 当容器元素有支持 aria-activedescendant 的 ARIA 的角色，并且加载和创建完成，请确保：
	- 容器元素要像在[组件之间的键盘导航（Tab 序列）](#组件之间的键盘导航（Tab-序列）)里介绍的，要被包含在 tab 序列，或者要被实现为一个[流动 tabindex](#使用流动-tabindex-管理组件内的焦点)；
	- 当微件需要聚焦的时候，`aria-activedescendant="IDREF"` 的 IDREF 就是容器内活跃元素的 ID。被引用的元素要满足下面介绍的 DOM 关系。
- 当容器元素被聚焦，为活跃元素添加视觉上的聚焦指示，确保活跃元素滚动到了视线内；
- 当微件内有焦点，用户按下导航键想要移动焦点，例如方向键：
	- 改变容器元素的 `aria-activedescendant` 值，来指向一个元素来告诉辅助技术当前活跃的元素；
	- 移动视觉指示效果，有必要的话要滚动到视线区域。
- 如果设计上要求用户通过 <kbd>Tab</kbd> 和 <kbd>Shift+Tab</kbd> 聚焦组件的指定元素，那么当容器失焦的时候也要检查 aria-activedescendant 有没有指向目标元素，如果没有，要设置 aria-activedescendant 指向目标元素。

[aria-activedescendant 规范](https://w3c.github.io/aria/#aria-activedescendant)对于被聚焦的元素，含有属性 aria-activedescendant 以及作为属性值的被指向的被当作活跃的元素，在它们之间的 DOM 的关系上设定了重要的限制。下面属性条件的每一个都要被满足。
1. 被引用的活跃元素是被聚焦的发出引用的元素的后代；
2. 被聚焦的发起引用的元素有属性 [aria-owns](https://w3c.github.io/aria/#aria-owns)，属性的值是被引用元素的 ID；
3. 被聚焦的发起引用的元素的角色是 combobox、textbox 和 serchbox 其中之一，并且具有属性 [aria-controls](https://w3c.github.io/aria/#aria-controls)，该属性的值引用支持 aria-activedescendant 的角色的元素：
	1. 被引用的活跃元素是被控制元素的后代；
	2. 被控制元素有一个指定的 [aria-owns](https://w3c.github.io/aria/#aria-owns) 的值，该值是被引用的活跃元素的 ID。

## 禁用状态控件的可聚焦性

默认情况，禁用状态的 HTML input 元素是不在 tab 序列中的。大多数情况，我们对禁用状态的可交互元素的预期就是不可聚焦。但是，也有一些情况是需要让禁用的元素可聚焦，尤其在组合微件中的时候。举个例子，在[菜单和菜单栏模版](https://www.w3.org/WAI/ARIA/apg/patterns/menubar/)里，菜单里禁用状态的单项是可以通过方向键导航的时候聚焦到的。

移除禁用状态元素的可聚焦能力对用户来说是利弊双面的。如果允许用户跳过禁用的元素能减少完成任务所需要的按键次数。但是，阻止聚焦禁用元素会对屏幕阅读器用户隐藏它们的存在，屏幕阅读器的用户是通过移动焦点来“看”的。

我们建议开发者对于禁用状态元素的可聚焦性采用一致的约定。本指南采用下面的约定，约定既反映了常见做法，也试图平衡竞争问题。
1. 对于普通元素，非禁用状态的时候加入 tab 序列，禁用状态的时候移除 tab 序列；
2. 对于以下组合微件，即使禁用也保持可聚焦：
	- [列表框](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/)的选项；
	- [菜单和菜单栏](https://www.w3.org/WAI/ARIA/apg/patterns/menubar/)的单项；
	- [选项卡](https://www.w3.org/WAI/ARIA/apg/patterns/tabs/)的选项；
	- [树形视图](https://www.w3.org/WAI/ARIA/apg/patterns/treeview/)的单项。
3. 对于工具栏的元素，如果能够被发现很重要的话，就让它们可聚焦，下面有两个例子帮助我们判断：
	1. 一个工具栏，有在列表中实现了向上、向下、添加和移除单项的功能的按钮，这些按钮是“Up”、“Down”、“Add”和“Remove”。当列表第一个元素被选中的时候，“Up”是禁用状态的，而且也没有可聚焦性，由于有了“Down”的存在，所以“Up”的可发现性不是那么的重要；
	2. 一个编辑器中的工具栏，有一组特别的智能粘贴功能，当剪贴板为空或者剪贴板的内容不能被应用的时候，这一组智能粘贴应该是禁用状态的。如果找到这些功能主要是通过它们在工具栏上的存在的话，那么保持这些禁用按钮可聚焦对于用户就是有帮助的了。

减轻禁用元素在键盘焦点路径的影响的一种设计是，采用适当的[键盘快捷键](#键盘快捷键)。

## 常见功能的按键分配约定

下面的按键绑定可以被用在任何与其相关的习惯性功能的场景里。虽然 Windows 和 Linux 上的按键绑定的实现可以被用在 macOS 上，但使用 macOS 自己的按键绑定对用户来说会更可识别、更直观。有的时候，它也可以避免系统和浏览器的按键冲突。

| 功能 | Windows/Linux | macOS |
|:--|:--|:--|
| 打开 context 菜单 | <kbd>Shift + F10</kbd> |  |
| 复制到剪贴板 | <kbd>Control + C</kbd> | <kbd>Command + C</kbd> |
| 从剪贴板粘贴 | <kbd>Control + V</kbd> | <kbd>Command + V</kbd> |
| 剪贴到剪贴板 | <kbd>Control + X</kbd> | <kbd>Command + X</kbd> |
| 撤销 | <kbd>Control + Z</kbd> | <kbd>Command + Z</kbd> |
| 重做 | <kbd>Control + Y</kbd> | <kbd>Command + Shift + Z</kbd> |

## 键盘快捷键

> to be continued


















